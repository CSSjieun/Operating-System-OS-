Referenced by Youtube Channel Name: 동빈니

1. 컴퓨터 시스템의 처리 구조
User 사용자 <-> Application 응용 프로그램 <-> Operating System 운영 체제 <-> Hardware

2. 시스템의 발전
2.1 일괄처리 시스템 (Batch System): 초기의 컴퓨터가 동작하는 방식으로서 물리적으로 console에서 수행을 하던 방식에 사용하던 system입니다.
초기의 운영체제는 즉시적으로 데이터를 처리할 수 있는 여건 또한 갖추지 못했습니다.
따라서 그 대안으로 일괄처리 시스템이 운영체제에 도입이 됨으로써 비슷한 것은 주기적으로 한 버에 묶어서 처리할 수 있게 되었습니다.

User1
User2 -> Operator -> Batch1 & Batch2 -> Computer
User3

일괄처리 시스템은 처리 속도로 향상시키기 위해서 유사한 요구를 가지는 작업들을 함께 모아서 이들을 하나의 그룹으로 수행합니다.
다만 기계적인 입/출력 장치의 속도가 CPU와 같은 전자적인 장치의 속도보다 느리기 때문에 CPU가 계속해서 쉬는 상태(idle)인 경우가 많습니다.

2.2 다중 프로그램 시스템 (Multi-Programmed System): CPU가 수행할 작업을 항상 가지도록 하는 방식입니다.
먼저 하드 디스크나 SSD(SOlid State Disk)에서 여러 개의 프로그램을 선택해서 메인 메모리(RAM)에 적재합니다.
이후에 메모리 내에 있는 작업 중에서 하나를 선택해 차례대로 실행합니다. 
이 때 수행 중인 작업이 입/출력 등 때문에 기다리는 상태에 도달하면 CPU는 다른 작업으로 넘어서가서 수행을 계속합니다.
이후에 첫 번째 작업이 끝나면 현재의 작업을 중단하고 다시 첫 번째 작업이 CPU를 차지하게 되는 방식입니다.

다중 프로그램 시스템 덕분에 프로그램에서 카드를 읽거나 프린터를 쓰는 동의 시간에도 CPU를 계속해서 사용할 수 있게 되었습니다.

2.3 시분할 시스템 (Time-Sharing System): 다중 프로그램의 장점을 채택하여 확정한 시스템으로서 
프로그램이 수행이 되고 있을 때 아주 짧은 주기로 CPU를 각각의 프로그램에 할당을 해 주는 방법.
시분할 시스템으로 사용자는 프로그램이 수행이 되고 있는 동안에도 상호착용 Interact할 수 있게 됩니다.
아주 짧은 주기로 전환이 이루어지기 때문에 각 사용자는 모든 프로그램이 동시에 작동을 하고 있다고 느끼게 됩니다. 

예를 들면 Linux와 같은 운영체제는 여러 개의 사용자가 동시에 한 대의 컴퓨터에 접속을 해서 서로 다른 처리를 할 수 있도록 해주는데
이는 시분할 시스템을 적절하게 반영한 사례라고 할 수 있습니다. 

* 작업 스케줄링: 보조기억장치에 프로그램이 저장되어 있고 그 중 일부를 선택해서 메모리에 적재하는 전략입니다.
* CPU 스케줄링: 메모리에 올라온 작업들 중에서 무엇부터 실행할지 고르는 전략입니다.
* 일괄처리 시스템은 상호작용이 필요 없는 큰 단위의 작업들을 수행할 때 사용이 됩니다.

3. 다양한 시스템
3.1 다중 처리 시스템 Multiprocessor system: CPU가 여러 개인 시스템을 의미하며 각각의 CPU들이 아주 밀접하게 통신을 하는 구조를 가지고 있습니다.
당연히 성능이 하나의 CPU가 있을 때 보다 더 좋으며 하나의 처리기가 고장이 나더라도 속도가 느려질 뿐 시스템은 정상적으로 작동합니다. 

3.1.1 대칭적 다중 처리 시스템: 각 CPU가 하나의 운영체제 하에서 작동합니다. 또한 CPU끼리 데이터를 효율적으로 공유하는 구조로 운용이 됩니다. 

3.1.2 비대칭적 다중 처리 시스템: 각 처리기마다 특정한 작업이 정해져 있고 하나의 주요 CPU가 시스템을 제어하며 다른 CPU들은 미리 정의된 작업 혹은 명령을 수행합니다. 

3.2 분산 처리 시스템 Distributed Processing System: 네트워크를 이용해 동시에 작업을 처리하는 시스템으로 각각 CPU들은 메모리를 공유하지 않습니다. 
당연히 적절한 자원 공유로 계산 속도가 증가하고 신뢰성이 증가합니다. 

3.2.1 예시1
클라이언트 & 서버 시스템 (Client & Server System): 클라이언트가 서버로 어떠한 작업 요청을 보내고 서버는 그 작업을 수행해서 다시 클라이언트에게 응답을 보내는 구조입니다. 
대표적으로 웹 사이트와 접속자 사이의 관계를 이야기할 수 있습니다.

예시 2
P2P System(Peer-To-Peer System): 각 컴퓨터가 서버이자 클라이언트가 되는 시스템으로서 대표적인 예시로 토렌트(Torrent) 서비스가 있습니다.

3.3 클러스터 시스템 Clustered System: 물리적으로 많은 CPU를 한 곳에 모아서 특정한 작업을 수행하는 시스템입니다.
LAN (Local Area Network)으로 서로 연결된 각각의 CPU는 다른 CPU와 상호작용하여 고속 처리 서비스를 지원하게 됩니다.

3.3.1 대칭적 클러스터 시스템: 각각의 CPU가 호스트가 되어 서로를 관리하는 구조로 둘 이상의 작업을 수행할 수 있습니다.

3.3.2 비대칭적 클러스터 시스템: 호스트 CPU가 다른 CPU를 관리하면서 특정한 CPU가 작동을 중지하면 호스트 CPU가 작업을 돕는 구조입니다. 

3.4 실시간 시스템 Real-Time System: 실시간 시스템은 CPU의 동작이나 작업이 즉시적인 처리를 요구할 때 채택되는 시스템입니다. 
주로 의학 영상 시스템이나 무기 시스템에 실제로도 굉장히 많이 사용되고 있습니다.

3.4.1 연성 실시간 시스템 Soft Real-Time System: 더욱 우선순위를 가지고 빠르게 계산이 되긴해야 하지만 절대적으로 시간만을 중요시하지는 않는 시스템으로 일반 컴퓨터에도 많이 녹아 있는 구조입니다. 
음악 등을 들을 때는 웬만하면 컴퓨터가 렉이 걸려도 끊이지 않습니다.

3.4.2 경성 실시간 시스템 Hard Real-Time System: 빠른 시간이 절대적으로 요구되는 시스템으로 단기 메모만 써서 시간 엄수를 최우선적으로 끌어 올립니다. 
예를 들어 정밀하고 신속한 위치 판별을 요구하는 미사일 발사 시스템을 이야기 할 수 있습니다. 

4. 컴퓨터의 작동 과정
컴퓨터 시스템에서 CPU와 각 장치들은 서로 연결되어 메모리를 공유합니다. 
각각의 장치마다 장치 제어기 Controller가 작업을 도와주며 모든 기계들은 동기화되어 적절히 작동합니다.

4.1 컴퓨터의 부팅 과정
- 전원이 켜질 때 ROM(Read-Only Memory)에 저장된 초기 프로그램(Bootstrap)을 실행합니다.
- 초기 프로그램은 메모리, CPU 레지스터 등을 초기화시킵니다.
- 이후에 운영체제를 찾아서 메모리에 적재합니다.
- 운영체제는 첫 번째 프로세스를 즉시 실행합니다.
- 인터럽트가 발생하면서 CPU가 각종 작업을 처리합니다.

4.2 하드웨어와 소프트웨어는 모두 CPU에 인터럽트(event)를 발생시킬 수 있습니다. 
일반적으로 인터럽트는 입출력 연산이 종료되었을 때, 예외가 발생했을 때, 운영체제의 다양한 서비스를 요구할 때 등 다양한 이유로 발생할 수 있습니다.

4.3 인터럽트가 발생했을 때 CPU는 현재 하던 일을 중단하고, 그 인터럽트에 대한 처리를 먼저하게 됩니다. 
그러한 처리를 '서비스 루틴'이라고 하며 일반적으로 OS가 이를 처리합니다.
서비스 루틴이 종료가 되면 다시 CPU는 인터럽트 되었던 그 연산을 재개합니다. 

4.4 Interrupt가 요청되었을 때 처리할 수 있는 방법은 2가지 입니다.

(방법 1)

- 운영체제가 어떠한 종류의 인터럽트인지 확인합니다.
- 인터럽트 핸들러 Handler를 호출해서 인터럽트를 처리합니다.

(방법 2)

- 인터럽트가 요청이 되면 인터럽트 서비스 루틴의 주소를 가리키는 포인터들로 구성된 인터럽트 벡터 테이블을 참조합니다.
- 참조된 포인터가 가리키는 인터럽트 처리 루틴을 호출해서 인터럽트를 처리합니다. 

4.4.1 최근에는 방법 2를 채택한 운영체제가 많습니다. 인터럽트가 발생하면, OS는 하던 일에 대한 정보를 저장하고 중단합니다.
인터럽트 벡터로 제어를 옯겨 요청한 인터럽트 처리 루틴의 주소를 가리키는 포인터를 참조합니다.
포인터를 따라 이동하여 인터럽트 처리 루틴을 완료한 뒤에 다시 하던 일로 돌아갑니다. 

4.4.2 인터럽트가 실행이 되고 있을 때 다른 인터럽트가 또 발생하는 경우에는 다른 인터럽트들을 대기시킵니다. (동기화)
대기를 시키는 이유는 데이터 소실을 막기 위함입니다. 
또한 인터럽트 사이에는 우선순위가 있어서 우선순위에 따라서 인터럽트 처리 순서를 조절합니다. 

5. 입출력 시스템
5.1 입력 시스템의 작동 과정
(1) CPU가 장치제어기의 레지스터에 명령을 적재합니다. 
(2) 장치 제어기는 레지스터 내용을 조사하여 수행할 동작을 검사합니다.
(3) 레지스터 내용이 읽기 명령이므로 입력 장치에게 읽기 신호를 보냅니다.
(4) 입력 장치는 데이터를 읽어서 버퍼에 저장합니다. 
(5) 제어 부분은 CPU에 인터럽트를 발생시킵니다.
(6) CPU가 버퍼에서 데이터를 읽어 들이고 입력이 완료됩니다. 

5.2 장치 제어기: 공통 버스와 장치 사이에 위치하여 장치를 제어하는 역할을 합니다.
장치 제어기는 내부적으로 저장 장치를 가지고 있을 수 있으며 자신의 주변 장치와의 데이터 송수신을 할 수 있도록 인터페이스 역할을 합니다. 

5.3.1 동기식 입출력: 입출력이 시작되고 입출력이 끝난 후에 제어가 사용자 프로세스로 복귀하는 구조입니다.
매 순간마다 수행해야 할 입출력 요청은 하나가 되므로 운영체제는 어느 장치가 인터럽트를 호출하고 있는지 알고 있습니다.
다만 여러 장치에 대한 동시 입출력이 불가능하며 각종 유용한 연산들이 병행 실행될 가능성을 완전히 배제합니다.

5.3.2 비동기식 입출력: 입출력이 시작되고 끝나기 전에 사용자 프로그램으로 제어가 되돌아갑니다.
CPU가 하나의 요청을 보낸 다음에 인터럽트가 돌아오기 전까지 다른 일을 계속 수행할 수 있다는 장점을 가지고 있습니다.
다만 이 경우 입출력 장치 별로 장치의 종류, 주소, 상태 등의 정보를 매 순간 저장하여 관리할 필요가 있습니다.
이런 정보는 장치 상태 테이블의 형태로 저장되어 관리됩니다. 
또한 다른 프로세스들이 같은 장치에 대해 요청을 할 수 있기 때문에 운영체제는 매 장치를 위해서 대기 큐를 유지해야 합니다.
입출력이 실행되는 동안에도 다른 시스템 작업들을 병행할 수 있다는 점에서 효율성이 증가합니다.

5.4 DMA (Direct Memory Access) 구조
DMA 방식은 데이터를 낱개가 아니라 블록 단위로 전송하는 효율적인 방식 중 하나입니다.
DMA 방식을 채택하면 한 블록 단위의 데이터 전송을 할 때는 CPU의 간섭이 없고 자체적으로 입출력 작업을 처리할 수 있습니다. 
따라서 고속의 입출력 장치를 위해서 사용이 되며 기존에 발생했던 병목 현상을 개선하는 기술로 활용됩니다. 

5.4.1 DMA 입출력 방식의 작동 과정
(1) 운영체제가 입출력 요청을 보냅니다.
(2) DMA 제어기의 레지스터에 주소와 전송 길이가 저장됩니다.
(3) DMA 제어기는 한 블록의 입출력 동작을 수행하고 그 동안 CPU는 다른 작업을 합니다.
(4) 입출력 동작이 완료되면 DMA 제어기는 CPU에게 완료했다는 인터럽트를 보냅니다. 

6. 저장장치 구조
6.1 프로세스: 실행 중인 프로그램을 의미합니다.

6.2 주기억장치: 프로세스가 올라가는 공간입니다. 프로세서가 직접 접근할 수 있는 대량 저장 장치로서 워드의 배열로 구성되어 있습니다.
흔히 주기억장치와 RAM(Random-Acess Memory)은 같은 의미로 사용됩니다. 
또한 워드란 것은 CPU가 한 번에 처리할 수 있는 단위로서 운영체제가 32bit 시스템이라면 워드는 32bit가 됩니다.
주기억장치는 CPU와 상호작용할 수 있으며 상호작용을 할 때는 특정 기억장치 주소에 일련의 Load 혹은 Store 명령 등을 통하여 수행이 이루어집니다.
Load 명령은 주기억장치에서 CPU 내부의 register로 한 워드만큼의 데이터를 이동시키는 명령이며,
Store 명령은 CPU 내부의 register의 내용을 주기억장치로 이동시키는 명령입니다. 

6.3 하나의 명령이 실행되는 사이클은 다음과 같습니다.
(1) 기억장치로부터 명령을 인출해서 CPU 내부의 명령 레지스터에 저장합니다.
(2) CPU가 명령을 해독합니다.
(3) 피연산자를 CPU 내부의 레지스터에 저장합니다.
(4) 명령을 실행합니다.
(5) 결과를 기억장치에 저장합니다.

주기억 장치는 모든 프로그램과 자료를 영구히 저장하기에는 용량이 작으며 그 대신 보조기억장치보다 접근 속도가 훨씬 빠릅니다.
결과적으로 전원이 공급되지 않으면 그 내용을 잃어버리는 휘발성 저장장치라고 할 수 있습니다. 

6.4 보조기억장치: 프로그램을 영구히 저장할 수 있는 저장 장치로서 하드 디스크나 SSD(Solid State Drive) 등이 있습니다. 
아직도 가장 많이 사용되고 있는 보조기억장치는 하드 디스크로서 자기 디스크의 일종입니다.
일반적으로 프로그램들은 보조기억장치에 저장되며 그 중에서 실행을 한 프로그램이 프로세스가 되어 주기억장치에 적재되어 CPU가 처리해 프로그램이 작동하게 되는 것입니다.

또한 이외에도 캐시 메모리, CD-ROM, 자기 테이프 등 다양한 기타 저장 장치가 존재합니다.
물론 몇몇은 최근에 들어 거의 사용이 되지 있지 않지만 각각의 장치들은 속도, 가격, 크기, 휘발성 등의 특성에서 장단점이 존재하므로 이를 정확히 파악하는 것이 중요합니다.

6.5 주기억 장치는 중요하기 때문에 더욱 구체적으로 알 필요가 있습니다.
주기억 장치와 CPU 자체에 저장되어 있는 레지스터는 CPU가 직접 접근을 할 수 있는 유일한 저장장치입니다.
또한 당연한 소리이지만 실행 중인 모든 명령과, 명령에 의해서 사용이 되는 데이터는 항상 CPU가 직접 접근이 가능한 이러한 저장 장치 중 하나에 있어야만 합니다.

6.6 일반적인 입출력 장치에도 명령 및 전송되는 데이터를 보관하기 위하여 내부적으로 레지스터를 가지고 있습니다.
CPU는 특별한 입출력 명령을 내려 제어기의 레지스터 시스템 메모리간의 데이터 전송을 허용하는 방식으로 이러한 입출력 장치를 다룹니다.


6.7 기억장치 사상 입출력 Memory Mapped I/O
이전에는 입출력 명령이 각각의 입출력 장치를 ID값으로 구분하여 적절한 명령을 삽입하는 방식을 이용했는데,
이는 명령의 구조가 상이하여 파악하기 어렵다는 단점을 가져왔습니다.
그래서 단일 주소체계를 도입해서 명령의 구조를 통일하였는데 이를 기억장치 사상 입출력 방식이라고 합니다.
보다 편리한 입출력 장치에 대한 접근을 제공하고 메모리 주소의 일정 범위를 지정해서 장치 레지스터에 사상시킵니다.
보통 이러한 시스템은 모니터 화면 출력과 같이 고속의 응답 시간을 갖는 장치에 적합합니다. 
나중에는 이러한 시스템이 더 발전하여 그래픽 카드 등을 이요하는 방식으로 확장되었습니다.
그래픽 카드는 마치 별도의 CPU처럼 작동하여 게임 등을 할 때는 굉장히 중요한 요소로 사용이 됩니다.

6.8 자기 디스크 Magnetic Disk: 현재에도 가장 많이 보조기억장치로 사용이 되고 있는 매체로서 여러 개의 디스크 판이 함께 사용이 되는 경우가 많으며 각 디스크는 플래터 Platter라는 CD처럼 생긴 원형 평판으로 되어 있습니다.
Platter의 양쪽 표면은 자기적인 물질로 덮여 있으며 정보는 Platter 상에 자기적으로 기록되어 저장됩니다. 

읽기-쓰기 헤드 read-write head 는 모든 platter의 각 표면 바로 위에서 움직이며, head는 모든 head를 한꺼면에 이동시키는 디스크 arm에 부착되어 사용됩니다.
Platter의 표면은 원형인 track으로 논리적으로 구분이 되고 이 또한 섹토로 나뉘어져 있습니다.
Cylinder는 하나의 arm 위치에 있는 track의 집합을 의미하며, 모두 합쳐 수천 개의 동심원 cylinder가 존재할 수 있습니다.
또한 각 track 또한 수천개의 sector를 포함할 수 있어 다양한 용량의 magnetic disk가 존재합니다.

디스크의 속도 측면에서 중요한 특성은 바로 전송률입니다. 
전송률이란 드라이브와 컴퓨터 간의 데이터 전송 비율을 의미합니다.
임의 접근 시간 Random Access Time은 원하는 cylinder로 디스크 arm이 움직이는 탐색 시간 Seek Time과 원하는 섹터로 디스크 header가 회전하는 회전지연 Rotational Time 시간의 합으로 구성됩니다.
즉 하드 디스크에 있는 원하는 데이터를 찾으려면 arm을 움직여서 특정한 동심원 cylinder로 접근하고 디스크를 돌려서 특정 sector에 접근할 수 있도록 해야 하는 것입니다.

6.9 자기 테이프 Magnetic Tape: 초기의 보조기억장치로 사용된 매체로서 영구적이고 굉장히 많은 양의 데이터를 보관할 수 있습니다.
폭에 따라서 1/2인치 등으로 이름이 붙여지며 폭이 클수록 많은 양의 데이터를 저장할 수 있습니다. 
자기 테이프는 주기억장치와 비교했을 때 접근 시간 차이가 굉장히 느린데 이는 자기 테이프는 순차적인 접근만이 가능해서 자기 디스크가 제공하는 임의 접근 시간에 비해서 접근 속도가 굉장히 느리기 때문입니다. 


